# Find-the-Shortest-Path
Using different algorithms to solve the shortest path 使用不同算法求解最短路径  
人工智能与无人驾驶-课程作业  
大三下  
A*算法求解最短路径  
Dijkstra算法求解最短路径  

# 一、实验设计

## 1.1实验目的

在存在障碍物的二维网格中，使用A*算法高效找到起点（S）到终点（E）的最短路径，支持斜向移动（即8个方向）。

使用欧式距离作为启发函数，分析其对路径搜索方向的影响。

通过可视化工具直观展示网格地图、障碍物、起点、终点及最终路径，验证算法的正确性。

## 1.2实验所涉及的具体任务

使用欧式距离设计启发式函数，计算当前节点到终点的估计代价。

定义A*算法函数，使用A*算法搜索最短路径。

解析输入地图数据，并提取起点和终点。

运行A*算法函数，并输出最短路径。

采用可视化手段展示搜索结果。

## 1.3算法或方法的简要说明

八方向移动的A*算法，用于在二维网格地图中寻找起点到终点的最短路径。

### (1)算法核心步骤

开放列表：使用优先队列（堆）存储待探索节点，按f值（f = g + h）排序。

关闭列表：通过g_scores字典隐式管理，记录已探索节点的最小移动代价（g值）。

路径回溯：通过came_from字典记录每个节点的父节点，找到终点后反向回溯生成路径。

### (2)关键函数与参数

启发函数：

使用欧式距离估计当前点到终点的代价（h值）。

公式：
$$
h=\sqrt{\left(x_{\mathrm{end}}-x_{\mathrm{current}}\right)^2+\left(y_{\mathrm{end}}-y_{\mathrm{current}}\right)^2}
$$
移动规则：

八方向移动（包括上下左右及对角线方向）。

移动代价：

直线移动（上下左右）代价为1。

斜向移动（对角线）代价为√2（近似1.414）。

### (3)输入与解析

输入格式：

网格地图由字符组成：0表示可通行，1表示障碍物，S为起点，E为终点。

示例输入通过多行字符串定义地图（如代码中的input_data）。

解析过程：

将字符转换为二维数组，S和E的位置记录为坐标，并设为可通行区域。

### (4)路径搜索流程

初始化：

将起点加入开放列表，初始g值为0，f值为启发函数值。

循环探索：

从开放列表中取出f值最小的节点。

若到达终点，回溯生成路径。

遍历八方向邻居，计算移动代价和新的g值。

若新路径更优（g值更小），更新开放列表和路径记录。

终止条件：

开放列表为空时返回None，表示无可行路径。

### (5)可视化输出

颜色标记：

黑色：障碍物。

绿色：起点。

蓝色：终点。

红色：最终路径。

网格线：显示地图的单元格边界，便于观察路径走向。

### (6)关键优化点

优先队列：确保每次扩展的节点为当前最优选择。

g值校验：跳过开放列表中非最小g值的旧记录，避免重复计算。

斜向移动处理：区分直线与对角线移动代价，提升路径精度。

### (7)复杂度与适用性

时间复杂度：取决于启发函数的质量，最优情况下为O(bd)，其中b为分支因子，d为路径深度。

适用场景：适用于静态网格地图，支持任意起点与终点，可处理复杂障碍物分布。

# 二、实验过程

## 2.1环境配置

Python版本：3.7.9

第三方库：

Numpy ：用于数值计算。

Matplotlib ：用于数据可视化。

Heapq ：用于实现堆排序算法。

math ：用于数学计算。

## 2.2关键代码

### (1)启发函数 heuristic

功能：计算当前点到终点的欧式距离（允许8方向移动）。

实现：

```python
def heuristic(pos, end):
	return math.sqrt((end[0]-pos[0])**2 + (end[1]-pos[1])**2)
```

说明：用于估算当前点到终点的代价（h值），适用于斜向移动的场景。

### (2) A*算法主函数 astar

优先队列初始化：

```python
heapq.heappush(open_heap, (heuristic(start, end), 0, start[0], start[1]))
```

初始节点按f = g + h排序，其中g是实际移动代价，h是启发式估计值。

节点处理逻辑：

取出队列中f值最小的节点，若到达终点则回溯路径。

跳过无效的旧记录（current_g > g_scores）。

遍历8个方向，计算斜向移动代价（√2）或直线移动代价（1）。

更新更优路径的g_scores和came_from。

```python
# g_scores记录从起点到各节点的实际代价
    g_scores = {start: 0}  
    # came_from记录节点的前驱节点，用于路径回溯
    came_from = {}          
    
    # 主循环，处理开放列表中的节点
    while open_heap:
        # 取出当前f值最小的节点
        current_f, current_g, x, y = heapq.heappop(open_heap)
        current_pos = (x, y)
        
        # 若到达终点，重构并返回路径
        if current_pos == end:
            path = []
            # 通过前驱节点回溯路径
            while current_pos in came_from:
                path.append(current_pos)
                current_pos = came_from[current_pos]
            path.append(start)  # 添加起点
            path.reverse()      # 反转得到从起点到终点的路径
            return path, current_g
        
        # 如果当前节点的g值已不是最小，说明已有更优路径，跳过处理
        if current_g > g_scores.get(current_pos, float('inf')):
            continue
        
        # 遍历所有可能移动方向
        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            # 检查新坐标是否在网格范围内且可通行
            if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 0:
                # 计算移动代价：对角线移动为√2，直线移动为1
                move_cost = math.sqrt(2) if dx and dy else 1
                tentative_g = current_g + move_cost  # 暂定g值
                neighbor_pos = (nx, ny)
                
                # 如果新路径比已知路径更优
                if tentative_g < g_scores.get(neighbor_pos, float('inf')):
                    came_from[neighbor_pos] = current_pos  # 记录前驱节点
                    g_scores[neighbor_pos] = tentative_g  # 更新g值
                    # 计算f值（g值 + 启发式估计值）并加入开放列表
                    f = tentative_g + heuristic(neighbor_pos, end)
                    heapq.heappush(open_heap, (f, tentative_g, nx, ny))
```

### (3)输入数据解析

地图转换：

将字符串输入转换为二维数组，0表示可通行，1表示障碍物。

```python
map_row.append(0 if char in ('0', 'S', 'E') else 1)
```

起点/终点定位：

记录S和E的坐标，并将其设为可通行区域。

### (4)路径可视化

颜色标记：

障碍物：黑色 ([0, 0, 0])

起点：绿色 ([0, 1, 0])

终点：蓝色 ([0, 0, 1])

路径：红色线条

```python
# 设置颜色
grid = np.array(map_data)
image = np.ones((grid.shape[0], grid.shape[1], 3))  # 创建白色背景

image[grid == 1] = [0, 0, 0]  # 设置障碍为黑色

# 标记起点和终点
if start:
    image[start[0], start[1]] = [0, 1, 0]  # 起点绿色
if end:
    image[end[0], end[1]] = [0, 0, 1]  # 终点蓝色
```

坐标转换：

路径点的行索引对应y轴，列索引对应x轴，与imshow的坐标系匹配。

```python
# 绘制路径
if path:
    # 提取路径点的列索引作为x坐标，行索引作为y坐标
    x_coords = [y for (x, y) in path]
    y_coords = [x for (x, y) in path]
    plt.plot(x_coords, y_coords, color='red', linewidth=2)  # 用红色直线连接路径点
```

### (5)关键细节

斜向移动代价：

通过dx和dy判断是否为斜向移动，代价为√2。

```python
move_cost = math.sqrt(2) if dx and dy else 1
```

## 2.3关键步骤说明

### (1)启发函数

作用：估算当前节点到终点的预计代价（h值）。

实现：计算当前点与终点的欧式距离（允许斜向移动，适用于8邻居网格）。

### (2) A*主算法流程

初始化：

使用优先队列（堆）存储待探索节点，按f = g + h排序。

记录每个节点的实际移动代价（g_scores）和路径来源（came_from）。

节点扩展：

从堆中取出f值最小的节点。

若到达终点，回溯路径（通过came_from字典）。

遍历8个移动方向，计算斜向（√2）或直线（1）的移动代价。

若新路径更优（tentative_g < g_scores），更新g_scores和堆。

终止条件：

找到终点时返回路径；开放列表为空时返回 None。

### (3)输入数据解析

输入格式：字符串地图，S为起点，E为终点，0可通行，1为障碍。

转换逻辑：

将字符串逐行转换为二维数组，替换S和E为0（可通行）。

记录起点和终点的行列坐标。

### (4)路径搜索与结果输出

调用A*算法：传入地图、起点、终点，返回路径坐标列表或None。

输出：若存在路径，按顺序打印坐标；否则提示“未找到路径”。

### (5)可视化实现

颜色标记：

黑色：障碍物（1）。

绿色：起点（S）。

蓝色：终点（E）。

红色：最终路径。

# 三、实验结果与讨论

## 3.1实验结果展示

### (1)最短路径长度：39.56

### (2)最短路径坐标：

(1, 3)(2, 4)(3, 5)(4, 6)(4, 7)(5, 8)(6, 9)(6, 10)(6, 11)(6, 12)(6, 13)(6, 14)(6, 15)(6, 16)(6, 17)(6, 18)(6, 19)(6, 20)(6, 21)(6, 22)(6, 23)(6, 24)(6, 25)(7, 26)(7, 27)(7, 28)(8, 29)(8, 30)(8, 31)(9, 32)(10, 33)(10, 34)(11, 35)(11, 36)(11, 37)(12, 38)

### (3)可视化处理后生成的路径图：

![img](file:///C:\Users\Think\AppData\Local\Temp\ksohtml19596\wps2.jpg) 

 

## 3.2实验中遇到的问题

(1)若S或E被障碍物完全包围，算法会陷入死循环，需增加异常处理。

(2)缺少地图边界处理，未正确判断节点是否越界，导致程序崩溃。

(3)路径可能出现冗余，某些情况下路径绕远，需优化节点扩展顺序。

 

## 3.3对实验的改进或扩展的建议

(1)引入加权因子（如f(n)=g(n)+w*h(n)f(n)=g(n)+w*h(n)）平衡搜索速度与最优性。

(2)欧几里得距离在栅格地图中效率较低，改用曼哈顿距离后性能提升。其他启发函数（如曼哈顿距离）对比性能差异，或优化数据结构提升大规模地图的搜索效率。

(3)可以拓展至三维路径规划，应用于3D空间无人机或自动驾驶路径规划。
